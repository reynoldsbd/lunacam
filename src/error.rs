//! Error handling used throughout LunaCam

use std::fmt::Display;

use actix_web::HttpResponse;
use actix_web::error::ResponseError;
use actix_web::http::StatusCode;
use diesel::result::Error as DieselError;
use serde::Serialize;


/// Error type generated by LunaCam
#[derive(Debug, Display)]
pub enum Error {

    /// Error produced by a failed web request
    #[display(fmt = "{}", _1)]
    Web(StatusCode, String),

    /// Error propagated from a third-party library
    External(Box<dyn std::error::Error>),
}

impl Error {

    /// Returns a callback which creates a new `Error`
    ///
    /// The callback returns a new `Error::Web` variant with the status code
    /// specified by `status`. The error message is derived from the callback's
    /// first and only argument, via the `Display` trait.
    ///
    /// This method is indended to be used with `Result::map_err` as a quick
    /// means of overriding an error's status code while preserving it's string
    /// representation.
    pub fn with_status<E>(status: StatusCode) -> impl Fn(E) -> Self
    where
        E: Display
    {
        move |err| {
            Self::Web(status, format!("{}", err))
        }
    }
}

impl<T: std::error::Error + 'static> From<T> for Error {
    fn from(err: T) -> Self {
        Self::External(Box::new(err))
    }
}

impl ResponseError for Error {

    fn error_response(&self) -> HttpResponse {

        #[derive(Serialize)]
        struct ErrorBody<'a> {
            message: &'a str
        }

        let status = match self {
            Self::Web(status, _) => *status,
            Self::External(err) if err.downcast_ref() == Some(&DieselError::NotFound) =>
                StatusCode::NOT_FOUND,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };

        let body = ErrorBody {
            message: &format!("{}", self),
        };

        HttpResponse::build(status)
            .json(body)
    }
}


/// Result type generated by LunaCam
pub type Result<T> = std::result::Result<T, Error>;
