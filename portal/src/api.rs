//! Web API

use std::env;
use actix_web::{HttpResponse};
use actix_web::dev::{Body};
use actix_web::error::{ResponseError};
use actix_web::http::{StatusCode};
use actix_web::http::header::{self, HeaderValue};
use actix_web::web::{self, Data, Json, Path, ServiceConfig};
use diesel::prelude::*;
use diesel::sqlite::{SqliteConnection};
use log::{error};
use serde::{Deserialize, Serialize};
use crate::camera::{Camera, NewCamera, Orientation};


//#region Error Handling

/// Error generated by API operations
#[derive(Debug, Display)]
enum ApiError
{
    #[display(fmt = "{}", _1)]
    Custom(StatusCode, &'static str),
    Database(diesel::result::Error),
}

impl From<diesel::result::Error> for ApiError
{
    fn from(err: diesel::result::Error) -> Self
    {
        ApiError::Database(err)
    }
}

impl ResponseError for ApiError
{
    fn error_response(&self) -> HttpResponse
    {
        HttpResponse::new(match *self {
            ApiError::Database(diesel::result::Error::NotFound) => StatusCode::NOT_FOUND,
            ApiError::Custom(code, _) => code,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        })
    }

    fn render_response(&self) -> HttpResponse
    {
        let mut response = self.error_response();

        response.headers_mut()
            .insert(header::CONTENT_TYPE, HeaderValue::from_static("application/json"));

        response.set_body(Body::from(format!("{{\"message\": \"{}\"}}", self)))
    }
}

/// Result of API operations
type Result<T> = std::result::Result<T, ApiError>;

//#endregion


//#region CRUD for Cameras

/// Defines the JSON structure of a camera
#[derive(Clone, Debug, Deserialize, Serialize)]
struct CameraResource
{
    enabled: Option<bool>,
    hostname: Option<String>,
    id: Option<i32>,
    device_key: Option<String>,
    friendly_name: Option<String>,
    orientation: Option<Orientation>,
}

impl From<Camera> for CameraResource
{
    fn from(camera: Camera) -> Self
    {
        CameraResource {
            enabled: Some(camera.enabled),
            hostname: Some(camera.hostname),
            id: Some(camera.id),
            device_key: None, // TODO
            friendly_name: Some(camera.friendly_name),
            orientation: Some(camera.orientation),
        }
    }
}

fn put_camera(
    db: Data<SqliteConnection>,
    raw: Json<CameraResource>,
) -> Result<Json<CameraResource>>
{
    let raw = raw.into_inner();

    // Validate input
    if raw.id.is_some() {
        return Err(ApiError::Custom(
            StatusCode::BAD_REQUEST, "cannot specify id when creating new camera resource"
        ))
    }
    let new_camera = NewCamera {
        hostname: raw.hostname
            .ok_or(ApiError::Custom(StatusCode::BAD_REQUEST, "hostname is required"))?,
        device_key: raw.device_key
            .ok_or(ApiError::Custom(StatusCode::BAD_REQUEST, "device_key is required"))?,
        friendly_name: raw.friendly_name
            .ok_or(ApiError::Custom(StatusCode::BAD_REQUEST, "friendly_name is required"))?,
    };

    let mut camera = Camera::create(new_camera, &db)?;

    // TODO: replace with encapsulated camera api
    let mut save_needed = false;
    if let Some(enabled) = raw.enabled {
        camera.enabled = enabled;
        save_needed = true;
    }
    if let Some(orientation) = raw.orientation {
        camera.orientation = orientation;
        save_needed = true;
    }
    if save_needed {
        camera.save(&db)?;
    }

    Ok(Json(camera.into()))
}

fn get_camera(
    path: Path<(i32,)>,
    db: Data<SqliteConnection>,
) -> Result<Json<CameraResource>>
{
    Ok(Json(Camera::get(path.0, &db)?.into()))
}

fn get_cameras(
    db: Data<SqliteConnection>,
) -> Result<Json<Vec<CameraResource>>>
{
    let cameras = Camera::get_all(&db)?
        .into_iter()
        .map(|cam| cam.into())
        .collect();

    Ok(Json(cameras))
}

fn patch_camera(
    path: Path<(i32,)>,
    raw: Json<CameraResource>,
    db: Data<SqliteConnection>,
) -> Result<()>
{
    let raw = raw.into_inner();
    let mut camera = Camera::get(path.0, &db)?;

    // Sanity check
    if raw.id != Some(camera.id) {
        return Err(ApiError::Custom(StatusCode::NOT_FOUND, "id mismatch"));
    }

    if let Some(enabled) = raw.enabled {
        camera.enabled = enabled;
    }
    if let Some(hostname) = raw.hostname {
        camera.hostname = hostname;
    }
    if let Some(device_key) = raw.device_key {
        camera.device_key = device_key;
    }
    if let Some(friendly_name) = raw.friendly_name {
        camera.friendly_name = friendly_name;
    }
    if let Some(orientation) = raw.orientation {
        camera.orientation = orientation;
    }
    camera.save(&db)?;

    Ok(())
}

fn delete_camera(
    path: Path<(i32,)>,
    db: Data<SqliteConnection>,
) -> Result<()>
{
    Camera::get(path.0, &db)?
        .delete(&db)?;

    Ok(())
}

//#endregion


/// Configures an Actix service to serve the API
pub fn configure(service: &mut ServiceConfig)
{
    let database_url = unwrap_or_return!(env::var("DATABASE_URL"));
    let connection = unwrap_or_return!(SqliteConnection::establish(&database_url));

    service.data(connection);
    service.route("/cameras", web::get().to(get_cameras));
    service.route("/cameras", web::put().to(put_camera));
    service.route("/cameras/{id}", web::get().to(get_camera));
    service.route("/cameras/{id}", web::patch().to(patch_camera));
    service.route("/cameras/{id}", web::delete().to(delete_camera));
}
