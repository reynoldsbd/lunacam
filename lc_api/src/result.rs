use actix_web::HttpResponse;
use actix_web::dev::Body;
use actix_web::error::ResponseError;
use actix_web::http::StatusCode;
use actix_web::http::header::{self, HeaderValue};
use diesel::result::Error as DieselError;
use diesel::r2d2::PoolError;


/// Error generated by API operations
#[derive(Debug, Display, From)]
pub enum ApiError {
    #[display(fmt = "{}", _1)]
    Custom(StatusCode, &'static str),
    Database(DieselError),
    DatabasePool(PoolError),
}

impl ResponseError for ApiError {

    fn error_response(&self) -> HttpResponse {
        HttpResponse::new(match *self {
            Self::Database(DieselError::NotFound) => StatusCode::NOT_FOUND,
            Self::Custom(code, _) => code,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        })
    }

    fn render_response(&self) -> HttpResponse {
        let mut response = self.error_response();
        response.headers_mut()
            .insert(header::CONTENT_TYPE, HeaderValue::from_static("application/json"));

        response.set_body(
            Body::from(
                // TODO: don't serialize by hand
                format!("{{\"message\": \"{}\"}}", self)
            )
        )
    }
}


/// Result generated by API operations
pub type ApiResult<T> = std::result::Result<T, ApiError>;
